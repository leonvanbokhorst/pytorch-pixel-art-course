# Guide: 02 Firing Up the Pixel Factory: Using Your Model!

We've got the blueprint (`SimplePixelGenerator` class from Guide 1), now let's actually build the factory (create an instance) and make it churn out some pixels! This guide covers using your `nn.Module`, building on `01_...` and shown in `02_instantiating_using_model.py`.

**Core Concept:** The class definition is just the plan. To make pixels, you need to **instantiate** the class â€“ create an actual `SimplePixelGenerator` object. This object gets its own set of (initially random) internal knobs (weights & biases). Then, you feed it some starting material (like random noise) and it performs the steps defined in its `forward` method to produce output pixels.

## 1. Building the Factory (Instantiating the Model)

Creating your pixel generator object is like building any Python object. Call the class name, providing any arguments its `__init__` method needs (like the size of the input noise vector and the number of output pixels).

```python
# Spell Snippet:
# Assuming SimplePixelGenerator class is defined from Guide 1

NOISE_DIM = 10 # Size of the random input vector
NUM_PIXELS = 16 # We want to generate a 4x4 grayscale image (16 pixels total)

# Build the generator!
generator = SimplePixelGenerator(noise_dim=NOISE_DIM, num_pixels=NUM_PIXELS)
print(f"\nPixel Generator instantiated:\n{generator}")
# Output (example - shows the structure):
# Pixel Generator instantiated:
# SimplePixelGenerator(
#   (generator_layer): Linear(in_features=10, out_features=16, bias=True)
# )
```

- **What happened?** The `SimplePixelGenerator.__init__` method ran for _this specific_ `generator` object.
- `super().__init__()` set up the base.
- `self.generator_layer = nn.Linear(...)` created the specific linear layer inside _this_ `generator`. Its internal weights were randomly initialized, ready to learn (eventually!).

## 2. Preparing the Raw Material (Input Noise)

Generative models often start with random noise. We need to create a tensor of random numbers with the shape our generator expects. Usually, we process data in batches, so the shape is `(batch_size, noise_dimension)`.

```python
# Spell Snippet:
BATCH_SIZE = 1 # Let's generate one sprite for now

# Create a batch of random noise vectors
dummy_noise = torch.randn(BATCH_SIZE, NOISE_DIM)
print(f"\nCreated dummy noise input with shape: {dummy_noise.shape}")
# Output: Created dummy noise input with shape: torch.Size([1, 10])
```

## 3. Running the Factory (Calling the Model)

This is how you make pixels! You call the `generator` object directly, like it's a function, feeding it the `dummy_noise`.

**Super Important:** You **don't** call `generator.forward(dummy_noise)`. Just call `generator(dummy_noise)`. PyTorch handles running the `forward` method correctly behind the scenes.

Since we're just generating pixels here and not training (no gradients needed!), we wrap this step in the `torch.no_grad()` chill zone for speed and memory efficiency.

```python
# Spell Snippet:
with torch.no_grad(): # Tell Autograd to relax!
    print(f"\nCalling generator(dummy_noise) to generate pixels...")
    generated_pixel_values = generator(dummy_noise)
```

- **`model.eval()` (Good Habit!):** While our current `SimplePixelGenerator` doesn't have layers affected by mode (like Dropout), it's excellent practice to call `generator.eval()` before doing inference/generation. This ensures consistent behavior if you later add such layers. Call `generator.train()` to switch back if needed.

## 4. Admiring the Output Pixels

The `generated_pixel_values` variable now holds the output from the generator's `forward` method.

```python
# Spell Snippet:
print(f"\nPixels generated by the model:")
print(f" - Output shape: {generated_pixel_values.shape}")
print(f" - Output tensor (flattened pixels):\n{generated_pixel_values}")

# Optional: Reshape to visualize as a 4x4 image
if NUM_PIXELS == 16:
    generated_sprite = generated_pixel_values.reshape(BATCH_SIZE, 4, 4)
    print(f"\nReshaped output (conceptual 4x4 sprite):\n{generated_sprite}")
# Output shape: torch.Size([1, 16]) (batch_size, num_pixels)
# Output tensor: Some random-looking numbers (since the generator isn't trained)
# Reshaped output: The same numbers arranged in a 4x4 grid
```

The output shape is `(batch_size, num_pixels)`. The actual pixel values will look random because the generator's `linear_layer` weights were initialized randomly. Training (Day 6!) is needed to make it generate something meaningful!

## Summary

Using your pixel model involves:

1.  **Instantiating:** Create the model object (`generator = SimplePixelGenerator(...)`).
2.  **Preparing Input:** Create input data (like noise) with the right shape (`(batch_size, noise_dim)`).
3.  **Calling:** Feed the input to the model object (`pixels = generator(noise)`), usually inside `with torch.no_grad():` and after calling `model.eval()` for generation.
4.  **Output:** Get the resulting pixel tensor!

This separates the blueprint (class) from the factory (instance) and its operation.
